#!/usr/bin/env python
# coding: utf-8

# In[12]:


# This code is created for QC mentorship program 2021 - screening TASK 1, 

# The code below implements a subTask #1 of TASK#1 to create a variational/parametric circuit that can generate the most general 1 qubit 
# state. Here I have chosen two parameters, which are two well-known angles (a) rotation around Y axis and (b) rotation around Z axis, 
# These two parameters are assigned with random value between 0, pi for parameter parm_angleY, and a random value between 0, # 2pi for parm_AngleZ

# The arbitrary state is generated by first rotating state vector around Y and then around Z axes, In section below the Cartesian 
# coordinates of this vector state have been calculated for Bloch sphere and a check was also made that the sum of the squares adds to 1, also it can be noted that a valid pure quantum state is plotted by plot_bloch_vector below


get_ipython().run_line_magic('matplotlib', 'inline')
# Importing standard Qiskit libraries
from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *
import math 
from math import pi
import numpy as np
# IBMQ.load_accounts()  # there is no need to execute circuit on IBMQ for this task
# provider = IBMQ.load_account()


# In[27]:


# Initialize Quantum and classical registers, however there are no measurements performed and classical bit is 
# added for neat display of circuit

qreg =  QuantumRegister(1, 'randon qubit') # create and initializes a quantum register with one qubit to hold randon value
creg =  ClassicalRegister(1, 'measurement bit') # initialize a classical register with one classical bit to measure
qcr = QuantumCircuit(qreg, creg)  # define a quantum circuit with one qubit and one classical bit

# prepare two random values to generate a random qubit state from a intial quantum state '|0>' 
rotY = np.random.random() * pi    # obtain random value for rotY to rotate state around Y axis between 0 to 180 degrees
rotZ = np.random.random() * 2*pi  # obtain a random values for rotZ to rotate state around Z axis between 0 to 360 degrees
print(' Values of two rotational parameters ', rotY, rotZ)

# Rotate the state of qubit using two randomaly generated values rotY & rotZ
qcr.ry(rotY, qreg)   # rotate the state of third qubit around Y by the random angle value rotY,  
qcr.rz(rotZ, qreg)   # rotate the state of third qubit around Z by the random angle value rotZ   

qcr.draw()  # draw the circuit 


# In[29]:


# Execute circuit with statevector simulator to plot quantum state on bloch sphere, it valides the qubit statevector 

run_bkend = Aer.get_backend('statevector_simulator') 
fs = execute(qcr,run_bkend).result().get_statevector()
print (' This random state maps perfectly on the boch sphere as a valid quanutm state of a qubit ')
plot_bloch_multivector(fs)   # show the state generated with Random angles on a blochsphere 


# In[31]:


# Calculate the x, y and z cordinates on bloch sphere with help of randomly generated parameters    
cord_x = math.sin(rotY) * math.cos(rotZ)
cord_y = math.sin(rotY) * math.sin(rotZ)
cord_z = math.cos(rotY) 
print (' The values of cord_x, cord_y, cord_z on boch sphere ', cord_x, cord_y, cord_z, '\n')

# The normalization proves state the state created with random values of two parms indeed creates a valid pure 
# quanutm state situated on the surface of unit sphere X^2 + Y^2 + Z^2 = 1
print (' The tip of this state vector lies on the surface of unit  & the sum of sqaure of three cordinates is = ', round(cord_x**2  + cord_y**2 + cord_z**2,2), '\n')

# plot cordinates on x, y and z axes  
plot_bloch_vector([cord_x, cord_y, cord_z])


# In[ ]:


## End of Task1 part1##

